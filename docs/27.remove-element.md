# 27. Remove Element

## Methods
### [T = $O(n)$, S = $O(1)$] Single Pointer
Maintain a pointer `p` always pointing to a right-most non-target element. Iterate through the array from left, when finding a target element, swap with the non-target element, then move `p` to fix the constraint

### [T = $O(n)$, S = $O(1)$] Dual Pointer
Consider brute-force method, we use two nested for loops, each time meeting a target element, we use the inner loop to shift all elements(at the right of this element) left by one, it takes $O(n^2)$. Maintain two pointers, `p1` is the slow pointer that iterate through the array one by one; `p2` is the fast pointer that points to the element used to overwrite the slow pointer to make a correct shift. When `p1 == p2`, that means no overwrite is needed.

## Boundary Case
- empty, e.g. []\n 2
- empty after removing, e.g. [1]\n 1
- complex case, e.g. [0,4,4,0,4,4,4,0,2]\n 4

## Mappings